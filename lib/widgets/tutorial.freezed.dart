// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named

part of 'tutorial.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

class _$TutorialStateTearOff {
  const _$TutorialStateTearOff();

  Off off() {
    return const Off();
  }

  On on() {
    return const On();
  }

  AddPeopleTutorial onAddPeopleTutorial(int peopleCount) {
    return AddPeopleTutorial(
      peopleCount,
    );
  }

  TagsTutorial onTagsTutorial(TagsTutorialState state) {
    return TagsTutorial(
      state,
    );
  }
}

// ignore: unused_element
const $TutorialState = _$TutorialStateTearOff();

mixin _$TutorialState {
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result off(),
    @required Result on(),
    @required Result onAddPeopleTutorial(int peopleCount),
    @required Result onTagsTutorial(TagsTutorialState state),
  });
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result off(),
    Result on(),
    Result onAddPeopleTutorial(int peopleCount),
    Result onTagsTutorial(TagsTutorialState state),
    @required Result orElse(),
  });
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result off(Off value),
    @required Result on(On value),
    @required Result onAddPeopleTutorial(AddPeopleTutorial value),
    @required Result onTagsTutorial(TagsTutorial value),
  });
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result off(Off value),
    Result on(On value),
    Result onAddPeopleTutorial(AddPeopleTutorial value),
    Result onTagsTutorial(TagsTutorial value),
    @required Result orElse(),
  });
}

abstract class $TutorialStateCopyWith<$Res> {
  factory $TutorialStateCopyWith(
          TutorialState value, $Res Function(TutorialState) then) =
      _$TutorialStateCopyWithImpl<$Res>;
}

class _$TutorialStateCopyWithImpl<$Res>
    implements $TutorialStateCopyWith<$Res> {
  _$TutorialStateCopyWithImpl(this._value, this._then);

  final TutorialState _value;
  // ignore: unused_field
  final $Res Function(TutorialState) _then;
}

abstract class $OffCopyWith<$Res> {
  factory $OffCopyWith(Off value, $Res Function(Off) then) =
      _$OffCopyWithImpl<$Res>;
}

class _$OffCopyWithImpl<$Res> extends _$TutorialStateCopyWithImpl<$Res>
    implements $OffCopyWith<$Res> {
  _$OffCopyWithImpl(Off _value, $Res Function(Off) _then)
      : super(_value, (v) => _then(v as Off));

  @override
  Off get _value => super._value as Off;
}

class _$Off with DiagnosticableTreeMixin implements Off {
  const _$Off();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TutorialState.off()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'TutorialState.off'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is Off);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result off(),
    @required Result on(),
    @required Result onAddPeopleTutorial(int peopleCount),
    @required Result onTagsTutorial(TagsTutorialState state),
  }) {
    assert(off != null);
    assert(on != null);
    assert(onAddPeopleTutorial != null);
    assert(onTagsTutorial != null);
    return off();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result off(),
    Result on(),
    Result onAddPeopleTutorial(int peopleCount),
    Result onTagsTutorial(TagsTutorialState state),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (off != null) {
      return off();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result off(Off value),
    @required Result on(On value),
    @required Result onAddPeopleTutorial(AddPeopleTutorial value),
    @required Result onTagsTutorial(TagsTutorial value),
  }) {
    assert(off != null);
    assert(on != null);
    assert(onAddPeopleTutorial != null);
    assert(onTagsTutorial != null);
    return off(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result off(Off value),
    Result on(On value),
    Result onAddPeopleTutorial(AddPeopleTutorial value),
    Result onTagsTutorial(TagsTutorial value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (off != null) {
      return off(this);
    }
    return orElse();
  }
}

abstract class Off implements TutorialState {
  const factory Off() = _$Off;
}

abstract class $OnCopyWith<$Res> {
  factory $OnCopyWith(On value, $Res Function(On) then) =
      _$OnCopyWithImpl<$Res>;
}

class _$OnCopyWithImpl<$Res> extends _$TutorialStateCopyWithImpl<$Res>
    implements $OnCopyWith<$Res> {
  _$OnCopyWithImpl(On _value, $Res Function(On) _then)
      : super(_value, (v) => _then(v as On));

  @override
  On get _value => super._value as On;
}

class _$On with DiagnosticableTreeMixin implements On {
  const _$On();

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TutorialState.on()';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties..add(DiagnosticsProperty('type', 'TutorialState.on'));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is On);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result off(),
    @required Result on(),
    @required Result onAddPeopleTutorial(int peopleCount),
    @required Result onTagsTutorial(TagsTutorialState state),
  }) {
    assert(off != null);
    assert(on != null);
    assert(onAddPeopleTutorial != null);
    assert(onTagsTutorial != null);
    return on();
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result off(),
    Result on(),
    Result onAddPeopleTutorial(int peopleCount),
    Result onTagsTutorial(TagsTutorialState state),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (on != null) {
      return on();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result off(Off value),
    @required Result on(On value),
    @required Result onAddPeopleTutorial(AddPeopleTutorial value),
    @required Result onTagsTutorial(TagsTutorial value),
  }) {
    assert(off != null);
    assert(on != null);
    assert(onAddPeopleTutorial != null);
    assert(onTagsTutorial != null);
    return on(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result off(Off value),
    Result on(On value),
    Result onAddPeopleTutorial(AddPeopleTutorial value),
    Result onTagsTutorial(TagsTutorial value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (on != null) {
      return on(this);
    }
    return orElse();
  }
}

abstract class On implements TutorialState {
  const factory On() = _$On;
}

abstract class $AddPeopleTutorialCopyWith<$Res> {
  factory $AddPeopleTutorialCopyWith(
          AddPeopleTutorial value, $Res Function(AddPeopleTutorial) then) =
      _$AddPeopleTutorialCopyWithImpl<$Res>;
  $Res call({int peopleCount});
}

class _$AddPeopleTutorialCopyWithImpl<$Res>
    extends _$TutorialStateCopyWithImpl<$Res>
    implements $AddPeopleTutorialCopyWith<$Res> {
  _$AddPeopleTutorialCopyWithImpl(
      AddPeopleTutorial _value, $Res Function(AddPeopleTutorial) _then)
      : super(_value, (v) => _then(v as AddPeopleTutorial));

  @override
  AddPeopleTutorial get _value => super._value as AddPeopleTutorial;

  @override
  $Res call({
    Object peopleCount = freezed,
  }) {
    return _then(AddPeopleTutorial(
      peopleCount == freezed ? _value.peopleCount : peopleCount as int,
    ));
  }
}

class _$AddPeopleTutorial
    with DiagnosticableTreeMixin
    implements AddPeopleTutorial {
  const _$AddPeopleTutorial(this.peopleCount) : assert(peopleCount != null);

  @override
  final int peopleCount;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TutorialState.onAddPeopleTutorial(peopleCount: $peopleCount)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TutorialState.onAddPeopleTutorial'))
      ..add(DiagnosticsProperty('peopleCount', peopleCount));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is AddPeopleTutorial &&
            (identical(other.peopleCount, peopleCount) ||
                const DeepCollectionEquality()
                    .equals(other.peopleCount, peopleCount)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(peopleCount);

  @override
  $AddPeopleTutorialCopyWith<AddPeopleTutorial> get copyWith =>
      _$AddPeopleTutorialCopyWithImpl<AddPeopleTutorial>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result off(),
    @required Result on(),
    @required Result onAddPeopleTutorial(int peopleCount),
    @required Result onTagsTutorial(TagsTutorialState state),
  }) {
    assert(off != null);
    assert(on != null);
    assert(onAddPeopleTutorial != null);
    assert(onTagsTutorial != null);
    return onAddPeopleTutorial(peopleCount);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result off(),
    Result on(),
    Result onAddPeopleTutorial(int peopleCount),
    Result onTagsTutorial(TagsTutorialState state),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (onAddPeopleTutorial != null) {
      return onAddPeopleTutorial(peopleCount);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result off(Off value),
    @required Result on(On value),
    @required Result onAddPeopleTutorial(AddPeopleTutorial value),
    @required Result onTagsTutorial(TagsTutorial value),
  }) {
    assert(off != null);
    assert(on != null);
    assert(onAddPeopleTutorial != null);
    assert(onTagsTutorial != null);
    return onAddPeopleTutorial(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result off(Off value),
    Result on(On value),
    Result onAddPeopleTutorial(AddPeopleTutorial value),
    Result onTagsTutorial(TagsTutorial value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (onAddPeopleTutorial != null) {
      return onAddPeopleTutorial(this);
    }
    return orElse();
  }
}

abstract class AddPeopleTutorial implements TutorialState {
  const factory AddPeopleTutorial(int peopleCount) = _$AddPeopleTutorial;

  int get peopleCount;
  $AddPeopleTutorialCopyWith<AddPeopleTutorial> get copyWith;
}

abstract class $TagsTutorialCopyWith<$Res> {
  factory $TagsTutorialCopyWith(
          TagsTutorial value, $Res Function(TagsTutorial) then) =
      _$TagsTutorialCopyWithImpl<$Res>;
  $Res call({TagsTutorialState state});

  $TagsTutorialStateCopyWith<$Res> get state;
}

class _$TagsTutorialCopyWithImpl<$Res> extends _$TutorialStateCopyWithImpl<$Res>
    implements $TagsTutorialCopyWith<$Res> {
  _$TagsTutorialCopyWithImpl(
      TagsTutorial _value, $Res Function(TagsTutorial) _then)
      : super(_value, (v) => _then(v as TagsTutorial));

  @override
  TagsTutorial get _value => super._value as TagsTutorial;

  @override
  $Res call({
    Object state = freezed,
  }) {
    return _then(TagsTutorial(
      state == freezed ? _value.state : state as TagsTutorialState,
    ));
  }

  @override
  $TagsTutorialStateCopyWith<$Res> get state {
    if (_value.state == null) {
      return null;
    }
    return $TagsTutorialStateCopyWith<$Res>(_value.state, (value) {
      return _then(_value.copyWith(state: value));
    });
  }
}

class _$TagsTutorial with DiagnosticableTreeMixin implements TagsTutorial {
  const _$TagsTutorial(this.state) : assert(state != null);

  @override
  final TagsTutorialState state;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TutorialState.onTagsTutorial(state: $state)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TutorialState.onTagsTutorial'))
      ..add(DiagnosticsProperty('state', state));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is TagsTutorial &&
            (identical(other.state, state) ||
                const DeepCollectionEquality().equals(other.state, state)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^ const DeepCollectionEquality().hash(state);

  @override
  $TagsTutorialCopyWith<TagsTutorial> get copyWith =>
      _$TagsTutorialCopyWithImpl<TagsTutorial>(this, _$identity);

  @override
  @optionalTypeArgs
  Result when<Result extends Object>({
    @required Result off(),
    @required Result on(),
    @required Result onAddPeopleTutorial(int peopleCount),
    @required Result onTagsTutorial(TagsTutorialState state),
  }) {
    assert(off != null);
    assert(on != null);
    assert(onAddPeopleTutorial != null);
    assert(onTagsTutorial != null);
    return onTagsTutorial(state);
  }

  @override
  @optionalTypeArgs
  Result maybeWhen<Result extends Object>({
    Result off(),
    Result on(),
    Result onAddPeopleTutorial(int peopleCount),
    Result onTagsTutorial(TagsTutorialState state),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (onTagsTutorial != null) {
      return onTagsTutorial(state);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  Result map<Result extends Object>({
    @required Result off(Off value),
    @required Result on(On value),
    @required Result onAddPeopleTutorial(AddPeopleTutorial value),
    @required Result onTagsTutorial(TagsTutorial value),
  }) {
    assert(off != null);
    assert(on != null);
    assert(onAddPeopleTutorial != null);
    assert(onTagsTutorial != null);
    return onTagsTutorial(this);
  }

  @override
  @optionalTypeArgs
  Result maybeMap<Result extends Object>({
    Result off(Off value),
    Result on(On value),
    Result onAddPeopleTutorial(AddPeopleTutorial value),
    Result onTagsTutorial(TagsTutorial value),
    @required Result orElse(),
  }) {
    assert(orElse != null);
    if (onTagsTutorial != null) {
      return onTagsTutorial(this);
    }
    return orElse();
  }
}

abstract class TagsTutorial implements TutorialState {
  const factory TagsTutorial(TagsTutorialState state) = _$TagsTutorial;

  TagsTutorialState get state;
  $TagsTutorialCopyWith<TagsTutorial> get copyWith;
}

class _$TagsTutorialStateTearOff {
  const _$TagsTutorialStateTearOff();

  _TagsTutorialState call(
      {Set<String> recentTagIds = const <String>{},
      Set<String> noteUsedTagIds = const <String>{},
      Set<String> viewedTagIds = const <String>{}}) {
    return _TagsTutorialState(
      recentTagIds: recentTagIds,
      noteUsedTagIds: noteUsedTagIds,
      viewedTagIds: viewedTagIds,
    );
  }
}

// ignore: unused_element
const $TagsTutorialState = _$TagsTutorialStateTearOff();

mixin _$TagsTutorialState {
  Set<String> get recentTagIds;
  Set<String> get noteUsedTagIds;
  Set<String> get viewedTagIds;

  $TagsTutorialStateCopyWith<TagsTutorialState> get copyWith;
}

abstract class $TagsTutorialStateCopyWith<$Res> {
  factory $TagsTutorialStateCopyWith(
          TagsTutorialState value, $Res Function(TagsTutorialState) then) =
      _$TagsTutorialStateCopyWithImpl<$Res>;
  $Res call(
      {Set<String> recentTagIds,
      Set<String> noteUsedTagIds,
      Set<String> viewedTagIds});
}

class _$TagsTutorialStateCopyWithImpl<$Res>
    implements $TagsTutorialStateCopyWith<$Res> {
  _$TagsTutorialStateCopyWithImpl(this._value, this._then);

  final TagsTutorialState _value;
  // ignore: unused_field
  final $Res Function(TagsTutorialState) _then;

  @override
  $Res call({
    Object recentTagIds = freezed,
    Object noteUsedTagIds = freezed,
    Object viewedTagIds = freezed,
  }) {
    return _then(_value.copyWith(
      recentTagIds: recentTagIds == freezed
          ? _value.recentTagIds
          : recentTagIds as Set<String>,
      noteUsedTagIds: noteUsedTagIds == freezed
          ? _value.noteUsedTagIds
          : noteUsedTagIds as Set<String>,
      viewedTagIds: viewedTagIds == freezed
          ? _value.viewedTagIds
          : viewedTagIds as Set<String>,
    ));
  }
}

abstract class _$TagsTutorialStateCopyWith<$Res>
    implements $TagsTutorialStateCopyWith<$Res> {
  factory _$TagsTutorialStateCopyWith(
          _TagsTutorialState value, $Res Function(_TagsTutorialState) then) =
      __$TagsTutorialStateCopyWithImpl<$Res>;
  @override
  $Res call(
      {Set<String> recentTagIds,
      Set<String> noteUsedTagIds,
      Set<String> viewedTagIds});
}

class __$TagsTutorialStateCopyWithImpl<$Res>
    extends _$TagsTutorialStateCopyWithImpl<$Res>
    implements _$TagsTutorialStateCopyWith<$Res> {
  __$TagsTutorialStateCopyWithImpl(
      _TagsTutorialState _value, $Res Function(_TagsTutorialState) _then)
      : super(_value, (v) => _then(v as _TagsTutorialState));

  @override
  _TagsTutorialState get _value => super._value as _TagsTutorialState;

  @override
  $Res call({
    Object recentTagIds = freezed,
    Object noteUsedTagIds = freezed,
    Object viewedTagIds = freezed,
  }) {
    return _then(_TagsTutorialState(
      recentTagIds: recentTagIds == freezed
          ? _value.recentTagIds
          : recentTagIds as Set<String>,
      noteUsedTagIds: noteUsedTagIds == freezed
          ? _value.noteUsedTagIds
          : noteUsedTagIds as Set<String>,
      viewedTagIds: viewedTagIds == freezed
          ? _value.viewedTagIds
          : viewedTagIds as Set<String>,
    ));
  }
}

class _$_TagsTutorialState
    with DiagnosticableTreeMixin
    implements _TagsTutorialState {
  _$_TagsTutorialState(
      {this.recentTagIds = const <String>{},
      this.noteUsedTagIds = const <String>{},
      this.viewedTagIds = const <String>{}})
      : assert(recentTagIds != null),
        assert(noteUsedTagIds != null),
        assert(viewedTagIds != null);

  @JsonKey(defaultValue: const <String>{})
  @override
  final Set<String> recentTagIds;
  @JsonKey(defaultValue: const <String>{})
  @override
  final Set<String> noteUsedTagIds;
  @JsonKey(defaultValue: const <String>{})
  @override
  final Set<String> viewedTagIds;

  @override
  String toString({DiagnosticLevel minLevel = DiagnosticLevel.info}) {
    return 'TagsTutorialState(recentTagIds: $recentTagIds, noteUsedTagIds: $noteUsedTagIds, viewedTagIds: $viewedTagIds)';
  }

  @override
  void debugFillProperties(DiagnosticPropertiesBuilder properties) {
    super.debugFillProperties(properties);
    properties
      ..add(DiagnosticsProperty('type', 'TagsTutorialState'))
      ..add(DiagnosticsProperty('recentTagIds', recentTagIds))
      ..add(DiagnosticsProperty('noteUsedTagIds', noteUsedTagIds))
      ..add(DiagnosticsProperty('viewedTagIds', viewedTagIds));
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _TagsTutorialState &&
            (identical(other.recentTagIds, recentTagIds) ||
                const DeepCollectionEquality()
                    .equals(other.recentTagIds, recentTagIds)) &&
            (identical(other.noteUsedTagIds, noteUsedTagIds) ||
                const DeepCollectionEquality()
                    .equals(other.noteUsedTagIds, noteUsedTagIds)) &&
            (identical(other.viewedTagIds, viewedTagIds) ||
                const DeepCollectionEquality()
                    .equals(other.viewedTagIds, viewedTagIds)));
  }

  @override
  int get hashCode =>
      runtimeType.hashCode ^
      const DeepCollectionEquality().hash(recentTagIds) ^
      const DeepCollectionEquality().hash(noteUsedTagIds) ^
      const DeepCollectionEquality().hash(viewedTagIds);

  @override
  _$TagsTutorialStateCopyWith<_TagsTutorialState> get copyWith =>
      __$TagsTutorialStateCopyWithImpl<_TagsTutorialState>(this, _$identity);
}

abstract class _TagsTutorialState implements TagsTutorialState {
  factory _TagsTutorialState(
      {Set<String> recentTagIds,
      Set<String> noteUsedTagIds,
      Set<String> viewedTagIds}) = _$_TagsTutorialState;

  @override
  Set<String> get recentTagIds;
  @override
  Set<String> get noteUsedTagIds;
  @override
  Set<String> get viewedTagIds;
  @override
  _$TagsTutorialStateCopyWith<_TagsTutorialState> get copyWith;
}
